/* tslint:disable */
/* eslint-disable */
/**
 * Twenty Api
 * This is a **Twenty REST/API** playground based on the **OpenAPI 3.1 specification**.
 *
 * The version of the OpenAPI document: v0.1
 * Contact: felix@twenty.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CreateManyPeople201Response } from '../model';
// @ts-ignore
import type { CreateOnePerson201Response } from '../model';
// @ts-ignore
import type { DeleteOnePerson200Response } from '../model';
// @ts-ignore
import type { FindManyPeople200Response } from '../model';
// @ts-ignore
import type { FindOnePerson200Response } from '../model';
// @ts-ignore
import type { FindPersonDuplicates200Response } from '../model';
// @ts-ignore
import type { FindPersonDuplicatesRequest } from '../model';
// @ts-ignore
import type { InlineObject } from '../model';
// @ts-ignore
import type { InlineObject1 } from '../model';
// @ts-ignore
import type { Person } from '../model';
// @ts-ignore
import type { PersonForUpdate } from '../model';
// @ts-ignore
import type { UpdateOnePerson200Response } from '../model';
/**
 * PeopleApi - axios parameter creator
 * @export
 */
export const PeopleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Many people
         * @param {Array<Person>} person 
         * @param {CreateManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyPeople: async (person: Array<Person>, depth?: CreateManyPeopleDepthEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'person' is not null or undefined
            assertParamExists('createManyPeople', 'person', person)
            const localVarPath = `/batch/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(person, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create One person
         * @param {Person} person body
         * @param {CreateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnePerson: async (person: Person, depth?: CreateOnePersonDepthEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'person' is not null or undefined
            assertParamExists('createOnePerson', 'person', person)
            const localVarPath = `/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(person, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete One person
         * @param {string} id Object id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnePerson: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOnePerson', 'id', id)
            const localVarPath = `/people/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **people**
         * @summary Find Many people
         * @param {string} [orderBy] Sorts objects returned.       Should have the following shape: **field_name_1,field_name_2[DIRECTION_2],...**       Available directions are **AscNullsFirst**, **AscNullsLast**, **DescNullsFirst**, **DescNullsLast**.       Default direction is **AscNullsFirst**
         * @param {string} [filter] Filters objects returned.       Should have the following shape: **field_1[COMPARATOR]:value_1,field_2[COMPARATOR]:value_2...     To filter on composite type fields use **field.subField[COMPARATOR]:value_1     **     Available comparators are **eq**, **neq**, **in**, **containsAny**, **is**, **gt**, **gte**, **lt**, **lte**, **startsWith**, **like**, **ilike**.       You can create more complex filters using conjunctions **or**, **and**, **not**.       Default root conjunction is **and**.       To filter **null** values use **field[is]:NULL** or **field[is]:NOT_NULL**       To filter using **boolean** values use **field[eq]:true** or **field[eq]:false**
         * @param {number} [limit] Limits the number of objects returned.
         * @param {FindManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {string} [startingAfter] Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
         * @param {string} [endingBefore] Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findManyPeople: async (orderBy?: string, filter?: string, limit?: number, depth?: FindManyPeopleDepthEnum, startingAfter?: string, endingBefore?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **depth** can be provided to request your **person**
         * @summary Find One person
         * @param {string} id Object id.
         * @param {FindOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePerson: async (id: string, depth?: FindOnePersonDepthEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOnePerson', 'id', id)
            const localVarPath = `/people/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **depth** can be provided to request your **person**
         * @summary Find person Duplicates
         * @param {FindPersonDuplicatesRequest} findPersonDuplicatesRequest body
         * @param {FindPersonDuplicatesDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersonDuplicates: async (findPersonDuplicatesRequest: FindPersonDuplicatesRequest, depth?: FindPersonDuplicatesDepthEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findPersonDuplicatesRequest' is not null or undefined
            assertParamExists('findPersonDuplicates', 'findPersonDuplicatesRequest', findPersonDuplicatesRequest)
            const localVarPath = `/people/duplicates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findPersonDuplicatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update One person
         * @param {string} id Object id.
         * @param {PersonForUpdate} personForUpdate body
         * @param {UpdateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOnePerson: async (id: string, personForUpdate: PersonForUpdate, depth?: UpdateOnePersonDepthEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOnePerson', 'id', id)
            // verify required parameter 'personForUpdate' is not null or undefined
            assertParamExists('updateOnePerson', 'personForUpdate', personForUpdate)
            const localVarPath = `/people/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personForUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleApi - functional programming interface
 * @export
 */
export const PeopleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Many people
         * @param {Array<Person>} person 
         * @param {CreateManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManyPeople(person: Array<Person>, depth?: CreateManyPeopleDepthEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateManyPeople201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManyPeople(person, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.createManyPeople']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create One person
         * @param {Person} person body
         * @param {CreateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOnePerson(person: Person, depth?: CreateOnePersonDepthEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOnePerson201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOnePerson(person, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.createOnePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete One person
         * @param {string} id Object id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOnePerson(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOnePerson200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOnePerson(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.deleteOnePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **people**
         * @summary Find Many people
         * @param {string} [orderBy] Sorts objects returned.       Should have the following shape: **field_name_1,field_name_2[DIRECTION_2],...**       Available directions are **AscNullsFirst**, **AscNullsLast**, **DescNullsFirst**, **DescNullsLast**.       Default direction is **AscNullsFirst**
         * @param {string} [filter] Filters objects returned.       Should have the following shape: **field_1[COMPARATOR]:value_1,field_2[COMPARATOR]:value_2...     To filter on composite type fields use **field.subField[COMPARATOR]:value_1     **     Available comparators are **eq**, **neq**, **in**, **containsAny**, **is**, **gt**, **gte**, **lt**, **lte**, **startsWith**, **like**, **ilike**.       You can create more complex filters using conjunctions **or**, **and**, **not**.       Default root conjunction is **and**.       To filter **null** values use **field[is]:NULL** or **field[is]:NOT_NULL**       To filter using **boolean** values use **field[eq]:true** or **field[eq]:false**
         * @param {number} [limit] Limits the number of objects returned.
         * @param {FindManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {string} [startingAfter] Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
         * @param {string} [endingBefore] Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findManyPeople(orderBy?: string, filter?: string, limit?: number, depth?: FindManyPeopleDepthEnum, startingAfter?: string, endingBefore?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyPeople200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findManyPeople(orderBy, filter, limit, depth, startingAfter, endingBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.findManyPeople']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **depth** can be provided to request your **person**
         * @summary Find One person
         * @param {string} id Object id.
         * @param {FindOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOnePerson(id: string, depth?: FindOnePersonDepthEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindOnePerson200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOnePerson(id, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.findOnePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **depth** can be provided to request your **person**
         * @summary Find person Duplicates
         * @param {FindPersonDuplicatesRequest} findPersonDuplicatesRequest body
         * @param {FindPersonDuplicatesDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPersonDuplicates(findPersonDuplicatesRequest: FindPersonDuplicatesRequest, depth?: FindPersonDuplicatesDepthEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindPersonDuplicates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPersonDuplicates(findPersonDuplicatesRequest, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.findPersonDuplicates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update One person
         * @param {string} id Object id.
         * @param {PersonForUpdate} personForUpdate body
         * @param {UpdateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOnePerson(id: string, personForUpdate: PersonForUpdate, depth?: UpdateOnePersonDepthEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOnePerson200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOnePerson(id, personForUpdate, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.updateOnePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleApi - factory interface
 * @export
 */
export const PeopleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Many people
         * @param {Array<Person>} person 
         * @param {CreateManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyPeople(person: Array<Person>, depth?: CreateManyPeopleDepthEnum, options?: RawAxiosRequestConfig): AxiosPromise<CreateManyPeople201Response> {
            return localVarFp.createManyPeople(person, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create One person
         * @param {Person} person body
         * @param {CreateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnePerson(person: Person, depth?: CreateOnePersonDepthEnum, options?: RawAxiosRequestConfig): AxiosPromise<CreateOnePerson201Response> {
            return localVarFp.createOnePerson(person, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete One person
         * @param {string} id Object id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnePerson(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOnePerson200Response> {
            return localVarFp.deleteOnePerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **people**
         * @summary Find Many people
         * @param {string} [orderBy] Sorts objects returned.       Should have the following shape: **field_name_1,field_name_2[DIRECTION_2],...**       Available directions are **AscNullsFirst**, **AscNullsLast**, **DescNullsFirst**, **DescNullsLast**.       Default direction is **AscNullsFirst**
         * @param {string} [filter] Filters objects returned.       Should have the following shape: **field_1[COMPARATOR]:value_1,field_2[COMPARATOR]:value_2...     To filter on composite type fields use **field.subField[COMPARATOR]:value_1     **     Available comparators are **eq**, **neq**, **in**, **containsAny**, **is**, **gt**, **gte**, **lt**, **lte**, **startsWith**, **like**, **ilike**.       You can create more complex filters using conjunctions **or**, **and**, **not**.       Default root conjunction is **and**.       To filter **null** values use **field[is]:NULL** or **field[is]:NOT_NULL**       To filter using **boolean** values use **field[eq]:true** or **field[eq]:false**
         * @param {number} [limit] Limits the number of objects returned.
         * @param {FindManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {string} [startingAfter] Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
         * @param {string} [endingBefore] Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findManyPeople(orderBy?: string, filter?: string, limit?: number, depth?: FindManyPeopleDepthEnum, startingAfter?: string, endingBefore?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyPeople200Response> {
            return localVarFp.findManyPeople(orderBy, filter, limit, depth, startingAfter, endingBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * **depth** can be provided to request your **person**
         * @summary Find One person
         * @param {string} id Object id.
         * @param {FindOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePerson(id: string, depth?: FindOnePersonDepthEnum, options?: RawAxiosRequestConfig): AxiosPromise<FindOnePerson200Response> {
            return localVarFp.findOnePerson(id, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * **depth** can be provided to request your **person**
         * @summary Find person Duplicates
         * @param {FindPersonDuplicatesRequest} findPersonDuplicatesRequest body
         * @param {FindPersonDuplicatesDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersonDuplicates(findPersonDuplicatesRequest: FindPersonDuplicatesRequest, depth?: FindPersonDuplicatesDepthEnum, options?: RawAxiosRequestConfig): AxiosPromise<FindPersonDuplicates200Response> {
            return localVarFp.findPersonDuplicates(findPersonDuplicatesRequest, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update One person
         * @param {string} id Object id.
         * @param {PersonForUpdate} personForUpdate body
         * @param {UpdateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOnePerson(id: string, personForUpdate: PersonForUpdate, depth?: UpdateOnePersonDepthEnum, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOnePerson200Response> {
            return localVarFp.updateOnePerson(id, personForUpdate, depth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleApi - object-oriented interface
 * @export
 * @class PeopleApi
 * @extends {BaseAPI}
 */
export class PeopleApi extends BaseAPI {
    /**
     * 
     * @summary Create Many people
     * @param {Array<Person>} person 
     * @param {CreateManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public createManyPeople(person: Array<Person>, depth?: CreateManyPeopleDepthEnum, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).createManyPeople(person, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create One person
     * @param {Person} person body
     * @param {CreateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public createOnePerson(person: Person, depth?: CreateOnePersonDepthEnum, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).createOnePerson(person, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete One person
     * @param {string} id Object id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public deleteOnePerson(id: string, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).deleteOnePerson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **people**
     * @summary Find Many people
     * @param {string} [orderBy] Sorts objects returned.       Should have the following shape: **field_name_1,field_name_2[DIRECTION_2],...**       Available directions are **AscNullsFirst**, **AscNullsLast**, **DescNullsFirst**, **DescNullsLast**.       Default direction is **AscNullsFirst**
     * @param {string} [filter] Filters objects returned.       Should have the following shape: **field_1[COMPARATOR]:value_1,field_2[COMPARATOR]:value_2...     To filter on composite type fields use **field.subField[COMPARATOR]:value_1     **     Available comparators are **eq**, **neq**, **in**, **containsAny**, **is**, **gt**, **gte**, **lt**, **lte**, **startsWith**, **like**, **ilike**.       You can create more complex filters using conjunctions **or**, **and**, **not**.       Default root conjunction is **and**.       To filter **null** values use **field[is]:NULL** or **field[is]:NOT_NULL**       To filter using **boolean** values use **field[eq]:true** or **field[eq]:false**
     * @param {number} [limit] Limits the number of objects returned.
     * @param {FindManyPeopleDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
     * @param {string} [startingAfter] Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
     * @param {string} [endingBefore] Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public findManyPeople(orderBy?: string, filter?: string, limit?: number, depth?: FindManyPeopleDepthEnum, startingAfter?: string, endingBefore?: string, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).findManyPeople(orderBy, filter, limit, depth, startingAfter, endingBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **depth** can be provided to request your **person**
     * @summary Find One person
     * @param {string} id Object id.
     * @param {FindOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public findOnePerson(id: string, depth?: FindOnePersonDepthEnum, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).findOnePerson(id, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **depth** can be provided to request your **person**
     * @summary Find person Duplicates
     * @param {FindPersonDuplicatesRequest} findPersonDuplicatesRequest body
     * @param {FindPersonDuplicatesDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public findPersonDuplicates(findPersonDuplicatesRequest: FindPersonDuplicatesRequest, depth?: FindPersonDuplicatesDepthEnum, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).findPersonDuplicates(findPersonDuplicatesRequest, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update One person
     * @param {string} id Object id.
     * @param {PersonForUpdate} personForUpdate body
     * @param {UpdateOnePersonDepthEnum} [depth] Determines the level of nested related objects to include in the response.       - 0: Returns only the primary object\&#39;s information.       - 1: Returns the primary object along with its directly related objects (with no additional nesting for related objects).       - 2: Returns the primary object, its directly related objects, and the related objects of those related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public updateOnePerson(id: string, personForUpdate: PersonForUpdate, depth?: UpdateOnePersonDepthEnum, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).updateOnePerson(id, personForUpdate, depth, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateManyPeopleDepthEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type CreateManyPeopleDepthEnum = typeof CreateManyPeopleDepthEnum[keyof typeof CreateManyPeopleDepthEnum];
/**
 * @export
 */
export const CreateOnePersonDepthEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type CreateOnePersonDepthEnum = typeof CreateOnePersonDepthEnum[keyof typeof CreateOnePersonDepthEnum];
/**
 * @export
 */
export const FindManyPeopleDepthEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type FindManyPeopleDepthEnum = typeof FindManyPeopleDepthEnum[keyof typeof FindManyPeopleDepthEnum];
/**
 * @export
 */
export const FindOnePersonDepthEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type FindOnePersonDepthEnum = typeof FindOnePersonDepthEnum[keyof typeof FindOnePersonDepthEnum];
/**
 * @export
 */
export const FindPersonDuplicatesDepthEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type FindPersonDuplicatesDepthEnum = typeof FindPersonDuplicatesDepthEnum[keyof typeof FindPersonDuplicatesDepthEnum];
/**
 * @export
 */
export const UpdateOnePersonDepthEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type UpdateOnePersonDepthEnum = typeof UpdateOnePersonDepthEnum[keyof typeof UpdateOnePersonDepthEnum];
